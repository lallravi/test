<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modeling IB Physics : Kinematics</title>
    
    <style>
        :root {
            --bg-color: #111827; --card-bg: #1f2937; --primary-text: #f9fafb; --secondary-text: #9ca3af;
            --accent-purple: #8b5cf6; --accent-blue: #38bdf8; --success-green: #4ade80; --failure-red: #f87171;
            --border-color: #374151; --shadow-color: rgba(0, 0, 0, 0.25);
            --graph-line-red: #f87171; --graph-axis-color: var(--secondary-text);
        }
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            font-size: 1rem; font-weight: 400; line-height: 1.5; color: var(--primary-text); background-color: var(--bg-color);
            margin: 0; padding: 1.5rem; display: flex; flex-direction: column; align-items: center;
        }
        .container {
            position: relative; width: 100%; max-width: 1400px; background: var(--card-bg); border-radius: 0.75rem;
            box-shadow: 0 0.5rem 1.5rem var(--shadow-color); padding: 2rem; box-sizing: border-box; border: 1px solid var(--border-color);
        }
        #corner-video {
            position: absolute; top: 1.5rem; right: 1.5rem; width: 220px; height: auto;
            border-radius: 0.5rem; opacity: 0.7; z-index: 10;
        }
        .header-container { display: flex; align-items: center; justify-content: center; gap: 20px; margin-bottom: 1rem; }
        #logo { height: 80px; width: auto; }
        h1 { margin: 0; font-size: 2.25rem; color: var(--primary-text); text-align: center; }
        h2, h3 { text-align: center; font-weight: 600; }
        h2 { font-size: 1.75rem; color: var(--accent-purple); }
        h3 { font-size: 1.25rem; color: var(--accent-blue); margin-bottom: 1rem; }
        p.description { text-align: center; font-size: 1.1rem; color: var(--secondary-text); max-width: 800px; margin: 0.5rem auto 2rem auto; }
        .controls-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 1.5rem 2.5rem;
            margin-bottom: 2rem; border-bottom: 1px solid var(--border-color); padding-bottom: 2rem;
        }
        .control-group { display: grid; grid-template-columns: 130px 1fr 80px; align-items: center; gap: 1rem; }
        .slider-label { font-weight: 500; text-align: right; color: var(--secondary-text); }
        .slider-value { font-weight: 600; color: var(--accent-purple); text-align: center; font-size: 1.1rem; }
        input[type="range"] { -webkit-appearance: none; width: 100%; height: 8px; background: var(--border-color); border-radius: 5px; outline: none; }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 20px; height: 20px; background: var(--accent-blue); cursor: pointer;
            border-radius: 50%; border: 2px solid var(--card-bg); box-shadow: 0 0 8px rgba(56, 189, 248, 0.5);
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px; height: 20px; background: var(--accent-blue); cursor: pointer; border-radius: 50%;
            border: 2px solid var(--card-bg); box-shadow: 0 0 8px rgba(56, 189, 248, 0.5);
        }
        .button-container { grid-column: 1 / -1; display: flex; justify-content: center; margin-top: 1rem; }
        #throwButton {
            padding: 0.8rem 2.5rem; font-size: 1.2rem; font-weight: 600; color: var(--primary-text);
            background-image: linear-gradient(to right, var(--accent-purple), var(--accent-blue));
            border: none; border-radius: 0.5rem; cursor: pointer; transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        #throwButton:hover { transform: translateY(-2px); box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4); }
        #throwButton:disabled { background-image: none; background-color: #555; cursor: not-allowed; transform: none; box-shadow: none; }
        .main-content-area { display: grid; grid-template-columns: 2.5fr 1fr; gap: 2rem; align-items: flex-start; margin-bottom: 2rem; }
        #simulationCanvas { width: 100%; height: auto; background-color: var(--card-bg); border-radius: 0.5rem; border: 1px solid var(--border-color); }
        .graphs-wrapper { display: flex; flex-direction: column; gap: 1.5rem; }
        .graph-container { background-color: var(--bg-color); border: 1px solid var(--border-color); border-radius: 0.5rem; padding: 1rem; }
        .output-panels { margin-top: 1rem; display: grid; grid-template-columns: 1fr; gap: 1rem; }
        #status, #velocity-display {
            font-size: 1.1rem; font-weight: 500; text-align: center; padding: 1rem; background-color: var(--bg-color);
            border: 1px solid var(--border-color); border-radius: 0.5rem; line-height: 1.6;
        }
        #velocity-display { font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-weight: 600; color: var(--accent-blue); }
        .guidance-section { margin-top: 2rem; padding-top: 2rem; border-top: 1px solid var(--border-color); }
        .guidance-section p { line-height: 1.7; color: var(--secondary-text); }
        .two-column-layout { display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin: 2rem 0; }
        .column { background-color: var(--bg-color); padding: 1.5rem; border-radius: 0.5rem; border: 1px solid var(--border-color); }
        .column h3 { color: var(--accent-blue); border-bottom: 1px solid var(--border-color); padding-bottom: 0.75rem; }
        .column ul { list-style-type: none; padding-left: 0; }
        .column li { margin-bottom: 0.75rem; }
        .equation-box {
            background-color: var(--bg-color); border-left: 4px solid var(--accent-blue); padding: 1.2rem; margin: 1.5rem 0;
            border-radius: 0.375rem; overflow-x: auto; text-align: center;
        }
        .final-equation-box { border-left-color: var(--success-green); }
        .equation {
            font-size: 1.2rem; font-family: "Georgia", "Cambria", "Times New Roman", serif; display: inline-flex;
            align-items: center; justify-content: center; flex-wrap: wrap; gap: 0.3em;
        }
        .equation b { color: var(--success-green); }
        .equation i { font-style: italic; }
        .equation sub, .equation sup { font-size: 0.8em; line-height: 1; position: relative; }
        .equation sup { bottom: 0.5em; }
        .equation sub { top: 0.3em; }
        .equation .fraction { display: inline-flex; flex-direction: column; text-align: center; vertical-align: middle; margin: 0 0.2em; }
        .equation .numerator { font-size: 1rem; padding: 0 0.2em; border-bottom: 1.5px solid var(--primary-text); }
        .equation .denominator { font-size: 1rem; padding: 0 0.2em; }
        @media (max-width: 1200px) { .main-content-area { grid-template-columns: 1fr; } }
        @media (max-width: 768px) {
            .header-container { flex-direction: column; gap: 10px; }
            .two-column-layout { grid-template-columns: 1fr; }
            .control-group { grid-template-columns: 1fr; text-align: center; }
            .slider-label { text-align: center; margin-bottom: 0.5rem; }
            h1 { font-size: 1.8rem; }
            .container { padding: 1rem; }
        }
    </style>
</head>
<body>

<div class="container">
    <video id="corner-video" autoplay muted loop>
      <source src="qua.mp4" type="video/mp4">
      Your browser does not support the video tag.
    </video>
    <div class="header-container">
        <img id="logo" src="lr-1.png" alt="Logo">
        <h1>Advanced Kinematics Simulator</h1>
    </div>
    <p class="description">
        Adjust the launch parameters to control the projectile's trajectory. The simulation models the flight path, while the analytical section calculates the outcome for the first arc.
    </p>

    <div class="controls-grid">
        <div class="control-group">
            <label class="slider-label" for="heightSlider">Building Height:</label>
            <input type="range" id="heightSlider" min="0" max="50" value="10" step="1">
            <span class="slider-value" id="heightValue">10 m</span>
        </div>
        <div class="control-group">
            <label class="slider-label" for="speedSlider">Launch Speed:</label>
            <input type="range" id="speedSlider" min="1" max="50" value="20" step="1">
            <span class="slider-value" id="speedValue">20 m/s</span>
        </div>
        <div class="control-group">
            <label class="slider-label" for="angleSlider">Launch Angle:</label>
            <input type="range" id="angleSlider" min="0" max="90" value="45" step="1">
            <span class="slider-value" id="angleValue">45 &deg;</span>
        </div>
        <div class="control-group">
            <label class="slider-label" for="wallDistSlider">Distance to Wall:</label>
            <input type="range" id="wallDistSlider" min="5" max="100" value="50" step="1">
            <span class="slider-value" id="wallDistValue">50 m</span>
        </div>
         <div class="control-group">
            <label class="slider-label" for="wallHeightSlider">Wall Height:</label>
            <input type="range" id="wallHeightSlider" min="1" max="50" value="10" step="1">
            <span class="slider-value" id="wallHeightValue">10 m</span>
        </div>
        <div class="control-group">
            <label class="slider-label" for="speedSimSlider">Sim Speed:</label>
            <input type="range" id="speedSimSlider" min="0.1" max="2" value="1" step="0.1">
            <span class="slider-value" id="speedSimValue">1.0x</span>
        </div>
        <div class="button-container">
            <button id="throwButton">Launch Projectile</button>
        </div>
    </div>

    <div class="main-content-area">
        <canvas id="simulationCanvas" width="800" height="500"></canvas>
        <div class="graphs-wrapper">
            <div class="graph-container">
                <h3>Vx vs. Time</h3>
                <canvas id="vxGraphCanvas" width="400" height="220"></canvas>
            </div>
            <div class="graph-container">
                <h3>Vy vs. Time</h3>
                <canvas id="vyGraphCanvas" width="400" height="220"></canvas>
            </div>
        </div>
    </div>

    <div class="output-panels">
        <div id="status">Adjust parameters and press "Launch Projectile".</div>
        <div id="velocity-display">Vx: 0.00 m/s | Vy: 0.00 m/s</div>
    </div>
    
    <div class="guidance-section">
        <div id="analytical-results">
             <h2>Analytical Prediction</h2>
             <p>Press "Launch Projectile" to calculate the analytical solution for the flight path based on the current parameters.</p>
        </div>
    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        const heightSlider = document.getElementById('heightSlider'), heightValueSpan = document.getElementById('heightValue');
        const speedSlider = document.getElementById('speedSlider'), speedValueSpan = document.getElementById('speedValue');
        const angleSlider = document.getElementById('angleSlider'), angleValueSpan = document.getElementById('angleValue');
        const wallHeightSlider = document.getElementById('wallHeightSlider'), wallHeightValueSpan = document.getElementById('wallHeightValue');
        const wallDistSlider = document.getElementById('wallDistSlider'), wallDistValueSpan = document.getElementById('wallDistValue');
        const speedSimSlider = document.getElementById('speedSimSlider'), speedSimValueSpan = document.getElementById('speedSimValue');
        const throwButton = document.getElementById('throwButton');
        const statusDiv = document.getElementById('status');
        const velocityDisplay = document.getElementById('velocity-display');
        const vxGraphCanvas = document.getElementById('vxGraphCanvas'), vxCtx = vxGraphCanvas.getContext('2d');
        const vyGraphCanvas = document.getElementById('vyGraphCanvas'), vyCtx = vyGraphCanvas.getContext('2d');
        const analyticalResultsDiv = document.getElementById('analytical-results');
        
        const G = 9.81;
        
        let initialHeight, initialSpeed, launchAngleDeg, wallHeight, wallDistance, timeScale;
        let animationFrameId = null;
        let ball = { x: 0, y: 0, vx: 0, vy: 0, radius: 0.5 };
        let trajectory = [], vxData = [], vyData = [];
        let time = 0;
        let simState = 'idle';
        
        function getScale() {
            const maxRange = Math.max(wallDistance + 20, 80);
            return (canvas.width - 80) / maxRange;
        }

        function transform(x_m, y_m) {
            const scale = getScale();
            const groundLevel = canvas.height - 40;
            return { x: 40 + x_m * scale, y: groundLevel - y_m * scale };
        }

        function drawScene() {
            const groundLevel = canvas.height - 40;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--card-bg').trim();
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = '#8B5C3B'; ctx.lineWidth = 4;
            ctx.beginPath(); ctx.moveTo(0, groundLevel); ctx.lineTo(canvas.width, groundLevel); ctx.stroke();
            
            const buildingTopLeft = transform(0, initialHeight);
            const buildingWidth = 40;
            ctx.fillStyle = '#94A3B8';
            ctx.fillRect(buildingTopLeft.x - buildingWidth, buildingTopLeft.y, buildingWidth, canvas.height - buildingTopLeft.y - (canvas.height - groundLevel));

            const wallTopLeft = transform(wallDistance, wallHeight);
            const wallPixelHeight = groundLevel - wallTopLeft.y;
            ctx.fillStyle = '#64748b';
            ctx.fillRect(wallTopLeft.x, wallTopLeft.y, 10, Math.max(0, wallPixelHeight));

            const launchPos = transform(0, initialHeight);
            const launchAngleRad = launchAngleDeg * Math.PI / 180;
            ctx.save();
            ctx.translate(launchPos.x, launchPos.y);
            ctx.rotate(-launchAngleRad);
            ctx.fillStyle = "#FDE047";
            ctx.fillRect(0, -5, 20, 10);
            ctx.restore();
        }
        
        // --- NEW HELPER FUNCTION TO DRAW ARROWS ---
        function drawArrow(fromX, fromY, toX, toY, color) {
            const headlen = 8;
            const dx = toX - fromX;
            const dy = toY - fromY;
            const angle = Math.atan2(dy, dx);
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
            ctx.stroke();
        }

        function drawBallAndTrajectory() {
            // Draw Trajectory
            if (trajectory.length > 1) {
                ctx.strokeStyle = 'rgba(56, 189, 248, 0.7)'; ctx.lineWidth = 2.5;
                ctx.beginPath();
                const startPoint = transform(trajectory[0].x, trajectory[0].y);
                ctx.moveTo(startPoint.x, startPoint.y);
                for (let i = 1; i < trajectory.length; i++) {
                     ctx.lineTo(transform(trajectory[i].x, trajectory[i].y).x, transform(trajectory[i].y, trajectory[i].y).y);
                }
                ctx.stroke();
            }
            
            // Draw Ball
            const ballPos = transform(ball.x, ball.y);
            ctx.fillStyle = '#FDE047';
            ctx.beginPath();
            const ballPixelRadius = transform(ball.radius, 0).x - transform(0,0).x;
            ctx.arc(ballPos.x, ballPos.y, Math.max(3, ballPixelRadius), 0, 2 * Math.PI);
            ctx.fill();

            // --- DRAW VELOCITY VECTORS ---
            const vectorScale = 3; // Adjust for nice length
            const vxColor = '#A78BFA'; // Purple
            const vyColor = '#F472B6'; // Pink
            
            // Draw Vx vector
            const vx_end_x = ballPos.x + ball.vx * vectorScale;
            drawArrow(ballPos.x, ballPos.y, vx_end_x, ballPos.y, vxColor);
            ctx.fillStyle = vxColor;
            ctx.font = 'bold 12px system-ui';
            ctx.fillText('Vx', vx_end_x + 5, ballPos.y + 4);

            // Draw Vy vector
            const vy_end_y = ballPos.y - ball.vy * vectorScale; // Subtract because canvas Y is inverted
            drawArrow(ballPos.x, ballPos.y, ballPos.x, vy_end_y, vyColor);
            ctx.fillStyle = vyColor;
            ctx.fillText('Vy', ballPos.x + 5, vy_end_y - 5);
        }

        function drawGraph(gCtx, data, timeLimit, yRange, color) {
            const w = gCtx.canvas.width, h = gCtx.canvas.height;
            const padX = 40, padY = 25;
            gCtx.clearRect(0, 0, w, h);
            const axisColor = getComputedStyle(document.documentElement).getPropertyValue('--graph-axis-color').trim();
            gCtx.strokeStyle = axisColor; gCtx.fillStyle = axisColor;
            gCtx.lineWidth = 1; gCtx.font = '11px system-ui';
            gCtx.beginPath(); gCtx.moveTo(padX, padY); gCtx.lineTo(padX, h - padY); gCtx.lineTo(w - padX, h - padY); gCtx.stroke();
            const yLabels = [yRange.min, (yRange.min + yRange.max) / 2, yRange.max];
            yLabels.forEach(val => {
                const y = h - padY - ((val - yRange.min) / (yRange.max - yRange.min)) * (h - 2 * padY);
                gCtx.textAlign = 'right'; gCtx.textBaseline = 'middle';
                gCtx.fillText(val.toFixed(1), padX - 8, y);
            });
            const xLabels = [0, timeLimit / 2, timeLimit];
            xLabels.forEach(val => {
                const x = padX + (val / timeLimit) * (w - 2 * padX);
                gCtx.textAlign = 'center'; gCtx.textBaseline = 'top';
                gCtx.fillText(val.toFixed(1) + 's', x, h - padY + 5);
            });
            if (data.length < 2) return;
            gCtx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue(color).trim();
            gCtx.lineWidth = 2.5;
            gCtx.beginPath();
            data.forEach((point, i) => {
                const x = padX + (point.time / timeLimit) * (w - 2 * padX);
                const y = h - padY - ((point.value - yRange.min) / (yRange.max - yRange.min)) * (h - 2 * padY);
                if (i === 0) gCtx.moveTo(x, y); else gCtx.lineTo(x, y);
            });
            gCtx.stroke();
        }

        function drawAllGraphs() {
            const timeLimit = time > 1 ? time : 1;
            const vxMax = Math.max(...vxData.map(p => Math.abs(p.value)), Math.abs(ball.vx)) + 2;
            drawGraph(vxCtx, vxData, timeLimit, {min: -vxMax, max: vxMax}, '--graph-line-red');
            const vyMax = Math.max(...vyData.map(p => Math.abs(p.value)), Math.abs(ball.vy)) + 5;
            drawGraph(vyCtx, vyData, timeLimit, {min: -vyMax, max: vyMax}, '--graph-line-red');
        }

        function startSimulation() {
            if (simState === 'running') return;
            simState = 'running';
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            updateAllValues();
            displayAnalyticalSolution();

            time = 0;
            trajectory = []; vxData = []; vyData = [];
            
            const launchAngleRad = launchAngleDeg * Math.PI / 180;
            ball.vx = initialSpeed * Math.cos(launchAngleRad);
            ball.vy = initialSpeed * Math.sin(launchAngleRad);
            ball.x = 0; ball.y = initialHeight;
            
            trajectory.push({ x: ball.x, y: ball.y });
            vxData.push({ time: 0, value: ball.vx });
            vyData.push({ time: 0, value: ball.vy });
            
            statusDiv.textContent = 'In motion...';
            throwButton.disabled = true;
            
            let lastTimestamp = 0;
            function animate(timestamp) {
                if (!lastTimestamp) lastTimestamp = timestamp;
                const frameTime = (timestamp - lastTimestamp) / 1000;
                lastTimestamp = timestamp;
                
                if (frameTime > 0.1) {
                    animationFrameId = requestAnimationFrame(animate);
                    return;
                }
                
                const dt = frameTime * timeScale;
                updateBallState(dt);

                let hitWall = (ball.x >= wallDistance - ball.radius) && ball.y <= wallHeight;
                let hitGround = (ball.y <= ball.radius && ball.vy < 0);

                if (hitWall || hitGround) {
                    if (hitWall) {
                        statusDiv.textContent = `Simulation stopped: Hit Wall at height ${ball.y.toFixed(2)} m.`;
                    } else {
                        statusDiv.textContent = `Simulation stopped: Hit Ground at range ${ball.x.toFixed(2)} m.`;
                    }
                    drawScene();
                    drawBallAndTrajectory();
                    drawAllGraphs();
                    throwButton.disabled = false;
                    simState = 'idle';
                    cancelAnimationFrame(animationFrameId);
                    return;
                }
                
                drawScene();
                drawBallAndTrajectory();
                drawAllGraphs();
                animationFrameId = requestAnimationFrame(animate);
            }
            animationFrameId = requestAnimationFrame(animate);
        }

        function updateBallState(dt) {
            ball.x += ball.vx * dt;
            ball.y += ball.vy * dt;
            ball.vy -= G * dt;
            
            time += dt;
            trajectory.push({ x: ball.x, y: ball.y });
            vxData.push({ time: time, value: ball.vx });
            vyData.push({ time: time, value: ball.vy });
            velocityDisplay.innerHTML = `Vx: ${ball.vx.toFixed(2)} m/s | Vy: ${ball.vy.toFixed(2)} m/s`;
        }
        
        function displayAnalyticalSolution() {
            const u = initialSpeed;
            const h = initialHeight;
            const d = wallDistance;
            const theta = launchAngleDeg * Math.PI / 180;
            
            const ux = u * Math.cos(theta);
            const uy = u * Math.sin(theta);

            const timeToWall = d / ux;
            const heightAtWall = h + (uy * timeToWall) - (0.5 * G * timeToWall**2);

            const vx_final_wall = ux;
            const vy_final_wall = uy - G * timeToWall;

            const v_final_mag_wall = Math.sqrt(vx_final_wall**2 + vy_final_wall**2);
            const v_final_angle_rad_wall = Math.atan2(vy_final_wall, vx_final_wall);
            const v_final_angle_deg_wall = v_final_angle_rad_wall * 180 / Math.PI;

            let outcome;
            if (heightAtWall > wallHeight) {
                outcome = `<span style="color: var(--success-green);">CLEARS THE WALL</span>`;
            } else if (heightAtWall >= 0) {
                outcome = `<span style="color: var(--failure-red);">HITS THE WALL</span>`;
            } else {
                outcome = `<span style="color: var(--secondary-text);">FALLS SHORT of the wall</span>`;
            }

            analyticalResultsDiv.innerHTML = `
                <h2>Analytical Prediction at Wall Distance (d = ${d}m)</h2>
                <p>Calculations for the projectile's state at the horizontal position of the wall.</p>
                <div class="two-column-layout">
                    <div class="column">
                        <h3>Horizontal Motion (SUVAT)</h3>
                        <ul>
                            <li><i>s<sub>x</sub></i> = <b>${d.toFixed(1)} m</b></li>
                            <li><i>u<sub>x</sub></i> = ${u.toFixed(1)}cos(${launchAngleDeg}°) = <b>${ux.toFixed(2)} m/s</b></li>
                            <li><i>v<sub>x</sub></i> = <i>u<sub>x</sub></i> = <b>${vx_final_wall.toFixed(2)} m/s</b></li>
                            <li><i>a<sub>x</sub></i> = <b>0 m/s²</b></li>
                        </ul>
                    </div>
                    <div class="column">
                        <h3>Vertical Motion (SUVAT)</h3>
                        <ul>
                            <li><i>s<sub>y</sub></i> = <b>?</b></li>
                            <li><i>u<sub>y</sub></i> = ${u.toFixed(1)}sin(${launchAngleDeg}°) = <b>${uy.toFixed(2)} m/s</b></li>
                            <li><i>v<sub>y</sub></i> = <b>?</b></li>
                            <li><i>a<sub>y</sub></i> = <b>-${G.toFixed(2)} m/s²</b></li>
                        </ul>
                    </div>
                </div>

                <h3>Step 1: Find Time to Reach Wall (<i>t</i>)</h3>
                <p>Using <i>s<sub>x</sub></i> = <i>u<sub>x</sub>t</i>:</p>
                <div class="equation-box">
                    <div class="equation">
                       <i>t</i> = <div class="fraction"><span class="numerator"><i>s<sub>x</sub></i></span><span class="denominator"><i>u<sub>x</sub></i></span></div>
                       = <div class="fraction"><span class="numerator">${d.toFixed(1)}</span><span class="denominator">${ux.toFixed(2)}</span></div>
                       = <b>${timeToWall.toFixed(2)} s</b>
                    </div>
                </div>

                <h3>Step 2: Find Height at Wall (<i>h<sub>wall</sub></i>)</h3>
                <p>Using <i>s<sub>y</sub></i> = <i>u<sub>y</sub>t</i> + ½<i>a<sub>y</sub>t</i>², where <i>s<sub>y</sub> = h<sub>wall</sub> - h<sub>initial</sub></i>:</p>
                <div class="equation-box">
                    <div class="equation">
                       <i>h<sub>wall</sub></i> = ${h.toFixed(1)} + (${uy.toFixed(2)})(${timeToWall.toFixed(2)}) - ½(${G.toFixed(2)})(${timeToWall.toFixed(2)})² = <b>${heightAtWall.toFixed(2)} m</b>
                    </div>
                </div>
                
                <h3>Step 3: Find Velocity at Wall</h3>
                <p>Using <i>v<sub>y</sub></i> = <i>u<sub>y</sub></i> + <i>a<sub>y</sub>t</i>:</p>
                 <div class="equation-box">
                    <div class="equation">
                       <i>v<sub>x</sub></i> = <b>${vx_final_wall.toFixed(2)} m/s</b>
                       &nbsp;|&nbsp;
                       <i>v<sub>y</sub></i> = ${uy.toFixed(2)} - ${G.toFixed(2)}(${timeToWall.toFixed(2)}) = <b>${vy_final_wall.toFixed(2)} m/s</b>
                    </div>
                </div>

                <div class="conclusion">
                    <h3>Final State at Wall Distance</h3>
                    <p>The projectile ${outcome} with the following properties:</p>
                    <div class="equation-box final-equation-box">
                       <div class="equation">
                          Resultant Velocity |<b><i>v</i></b>| = &radic;(${vx_final_wall.toFixed(2)}² + ${vy_final_wall.toFixed(2)}²) = <b>${v_final_mag_wall.toFixed(2)} m/s</b>
                       </div>
                       <div class="equation" style="margin-top:1rem;">
                          Impact Angle &theta; = arctan(${vy_final_wall.toFixed(2)} / ${vx_final_wall.toFixed(2)}) = <b>${v_final_angle_deg_wall.toFixed(1)}&deg;</b>
                       </div>
                    </div>
                </div>
            `;
        }

        function updateAllValues() {
            initialHeight = parseFloat(heightSlider.value);
            initialSpeed = parseFloat(speedSlider.value);
            launchAngleDeg = parseFloat(angleSlider.value);
            wallHeight = parseFloat(wallHeightSlider.value);
            wallDistance = parseFloat(wallDistSlider.value);
            timeScale = parseFloat(speedSimSlider.value);
            heightValueSpan.textContent = `${initialHeight.toFixed(1)} m`;
            speedValueSpan.textContent = `${initialSpeed.toFixed(1)} m/s`;
            angleValueSpan.textContent = `${launchAngleDeg.toFixed(0)} \u00B0`;
            wallHeightValueSpan.textContent = `${wallHeight.toFixed(1)} m`;
            wallDistValueSpan.textContent = `${wallDistance} m`;
            speedSimValueSpan.textContent = `${timeScale.toFixed(1)}x`;
        }

        function onSliderChange() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            simState = 'idle';
            throwButton.disabled = false;
            updateAllValues();
            drawScene();
            statusDiv.textContent = 'Adjust parameters and press "Launch Projectile".';
            velocityDisplay.innerHTML = `Vx: 0.00 m/s | Vy: 0.00 m/s`;
            vxCtx.clearRect(0,0,vxGraphCanvas.width, vxGraphCanvas.height);
            vyCtx.clearRect(0,0,vyGraphCanvas.width, vyGraphCanvas.height);
            analyticalResultsDiv.innerHTML = `
                <h2>Analytical Prediction (First Arc)</h2>
                <p>Press "Launch Projectile" to calculate the analytical solution based on the current parameters.</p>
            `;
        }
        
        [heightSlider, speedSlider, angleSlider, wallHeightSlider, wallDistSlider, speedSimSlider].forEach(slider => {
            slider.addEventListener('input', onSliderChange);
        });
        throwButton.addEventListener('click', startSimulation);
        
        onSliderChange();
    });
</script>

</body>
</html>
